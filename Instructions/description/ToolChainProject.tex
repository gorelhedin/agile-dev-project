\documentclass[swedish,english]{article}

\makeatletter\def\input@path{{../latex-style/}}\makeatother

\usepackage[latin1]{cs}
\usepackage{array,url,hyperref,kt,title}
\usepackage{fancyvrb} % supports \verb inside \footnote
\VerbatimFootnotes

\author{G{\"o}rel Hedin}
\title{Tool Chain Assignment}
\righthead{Software Development Course\cr WASP}
%\newcommand{\menuex}[1]{\begin{menuelist}#1\end{menuelist}}
%\newenvironment{menulist}{\begin{tabular}[h]{@{}>{\bf}c*{5}{@{}>{$\rightarrow$\bf}c}}}{\end{tabular}}

\renewenvironment{grammar}[1][$\rightarrow$]{\begin{tabular}{*{3}{l!{#1}l@{\qquad}}}}{\end{tabular}}
\renewcommand{\lit}[1]{\texttt{"#1"}}
\renewcommand{\mid}{\texttt{| }}
\newcommand{\code}[1]{\texttt{#1}}

\begin{document}
\maketitle[Version Control, Testing, Continuous Integration]

Estimated time: 2 days. We suggest splitting this into 4 half-day meetings.

Work in teams of 2-4 persons. Try to get at least one team member with experience from agile software development.

\section*{Introduction}

The goal is that you should set up and experiment with a development tool chain with version control, issue tracking, automated test and build, and continuous integration. If you are already very experienced in this area, take the opportunity to try out some new tools, and to coach your team members.

You will work in iterations, and build a tiny code product in Java, and use Java-based tools. After this assignment, you should be able to build a similar tool chain for your own work, and find tools suitable for the language you use. 

For each of the iterations, work together as a team, and sit co-located. We expect each iteration to take around a half day, but some may be shorter and others longer.

Code product: Pig Latin translator.
Implement a Java program that translates English words to Pig Latin. See \url{https://en.wikipedia.org/wiki/Pig_Latin}

We expect a usable, well-tested, but very tiny product as the result. You are expected to complete at least up to Iteration 3.

\subsection*{Iteration 1 (First iteration)}
- Set up a git repo for the product on GitHub. Make it a public repository (you will need this later for the continuous integration tool we will use). Add a README and a .gitignore file.

- Implement version v0.1 of your product. It should be the simplest possible version of the product that you can think of and it should be executable. For example, just read one word from the command line and output a constant pig latin word, disregarding the input. You will be able to create one working test case.

- Identify a number of possible features to add to the product, and add these as issues in the IssueTracker. Try to make the features as small as possible, yet represent something of use for the end user. For example,
  - use real Pig Latin
  - handle many words in a row, not just a single word
  - read from an input file
  - treat punctuation correctly
  - support a reverse translator
  - make it into a game
  - ...

- Implement one JUnit test for the version v0.1 product.

- Implement one acceptance test for the version v0.1 product.

- Implement an Ant build script from which you can
  - build the product (produce a jar file)
  - clean away generated files
  - run the tests

- Add a README.md to explain how to build, run, and test the product. And check that it works from a new clone of the product. The README should also document any platform dependencies and dependencies on installed tools. For any subsequent changes to the product, make sure to update the README so that it is consistent.

- Tag the resulting version with "v0.1".

\section*{Iteration 2 (Test-Driven Development)}

- Implement a couple of simple stories using TDD. 
- Generalize your test harness as needed.
- Add issues as needed. For example, if you find bugs, identify need for generalization or refactorings, or come to think of new possible additions.
- Commit and push often, but only when your sandbox is "green" and you have recently pulled the latest changes by others. For each commit, relate to the relevant issue in the commit comment (e.g., using "see ..." or "fixes ...").
- If you didn't get any merge conflicts naturally, provoke some, just to get the hang of how to handle them.
- Experiment with git rebase to collapse commits before pushing.

- Tag the resulting version with "v0.2".

\section*{Iteration 3 (Pull requests, Code Review, Continuous Integration)}



\section*{Iteration 4 (More advanced testing)}

Parameterized tests.
Random tests.
Theories?
Code coverage.
Metrics.



\end{document}
